<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>Projet WebGL 2019 - Université de Limoges</title>

		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>

	<body>
		<div id="info">
			Projet WebGL 2019 - Université de Limoges - Jonas FRANCESHI - Martin MORAND - Antoine TABARAUD
		</div>
		<script language="javascript">
			var derniereModif=document.lastModified;
			var dateModif = new Date(derniereModif);
			console.log("Dernière modification le "+dateModif);
		</script>
		<script src="./threejs/Tween.min.js"></script>
		<script type="module">
			import * as THREE from './threejs/three.module.js';
			import { MTLLoader } from './threejs/MTLLoader.js';
			import { OBJLoader } from './threejs/OBJLoader.js';
			import { TrackballControls } from './threejs/TrackballControls.js';


			var container;

			var camera, scene, renderer, controls, light;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			var object;

			var /*rail1, rail2,*/ terrain, locomotive;
			var geometryRail1=[], geometryRail2=[];
			var materialRail1=[], materialRail2=[];

			//afficher ou non les axes des différents objets
			var afficherAxes = false;

			//stockage des rails
			var rails1Tab = [];
			var rails2Tab = [];
			//nombre de rail dans chaque ligne droite
			var nbrRails = [20, 11, 14, 7, 25, 6, 4, 23, 4, 13, 12, 5, 22];
			//calcul du nombre total de rails (utilisé dans l'animation locomotive)
			var nbrTotalRails=0;
			for (let i = 0; i < nbrRails.length; i++) {
				nbrTotalRails+=nbrRails[i];
			}
			console.log("nb total de rail1: "+nbrTotalRails);


			// animation train
			var numRail = 0;

			var tween;
			var target1;

			//premier lancement des functions
			init();
			animate(new Date().getTime());

			function init() {
				container = document.createElement('div');
				document.body.appendChild(container);

				// scene
				scene = new THREE.Scene();

				if(afficherAxes){
					var axesScene = new THREE.AxesHelper(100);
					scene.add(axesScene);
				}

				createRenderer();
				createCamera();
				createControls();
				createLights();
				loadModels();




				// gestion redimensionnement fenetre
				window.addEventListener( 'resize', onWindowResize, false );
			}

			// creation renderer
			function createRenderer() {
				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setClearColor(0xAAAAAA, 1);
				renderer.shadowMap.enabled = true;
				container.appendChild(renderer.domElement);
			}

			// camera
			function createCamera() {
				camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 4000);
				camera.position.z = 700;
				camera.position.y = -1100;

				camera.lookAt(0, 0, 0);
				scene.add(camera);
			}

			function createControls() {
				// controle sur la camera, type trackball
				controls = new TrackballControls(camera, renderer.domElement);
			}

			// lights
			function createLights() {
				light = new THREE.PointLight(0xFFFFFF, 1.0);
				light.position.set(0, -500, 500);
				// enable shadows
				light.receiveShadow = true;
				light.castShadow = true;
				scene.add(light);

				//création d'une boule pour savoir où est la lumiere
				var lightSphere = new THREE.Mesh(new THREE.SphereBufferGeometry(50,20,20),
						new THREE.MeshStandardMaterial({emissive: 0xffffff,emissiveIntensity: light.intensity} ) );
				lightSphere.castShadow = true;
				light.add(lightSphere);
			}


			// load all models
			function loadModels() {

				// http://www.smartjava.org/content/render-3d-star-wars-force-awakens-models-blender-and-threejs/
				var textLoader = new THREE.TextureLoader();
				var diffuseTexture = textLoader.load("data/textures/Terrain/diffuse.png");
				var bumpTexture = textLoader.load("data/textures/Terrain/flows.png");
				var emissiveTexture = textLoader.load("data/textures/Terrain/hight.png");//montagnes (color white)
				//var specularTexture = textLoader.load("data/textures/Terrain/flows.png");

				function loadModel() {
					terrain.traverse(function (child) {
						if (child.isMesh){
							// http://www.smartjava.org/content/render-3d-star-wars-force-awakens-models-blender-and-threejs/
							var material = child.material;

							// basic texture
							material.map = diffuseTexture;


							// bumps (carte de niveau de hauteur à bas relief) perturbation de normal
						//	material.bumpMap = bumpTexture;
						//	material.bumpScale = -1.0;


							// glow
							material.emissive = new THREE.Color(0xffffff);//couleur blanche pour la neige
							material.emissiveMap = emissiveTexture;
							//material.emissive = new THREE.Color(0x0083ff);//couleur blanche pour la neige
							//material.emissiveMap = bumpTexture;

							// specular (relief)
							//material.specularMap = bumpTexture;

						}
					});

					scene.add(terrain);

				}

				// LoadingManager
				var manager = new THREE.LoadingManager(loadModel);
				manager.onStart = function ( item, loaded, total ) {
					console.log( 'Started loading file: ' + item + '.\nLoaded ' + loaded + ' of ' + total + ' files.' );
				};
				manager.onProgress = function (item, loaded, total) {
					console.log("Load:", item, "(", loaded, "/", total, ")");
				};
				manager.onError = function ( error ) {
					console.log( 'There was an error loading : ' + error );
				};



				// OBJLoader
				var objLoader = new OBJLoader(manager)
						.setPath( '/data/modifs/' );
				objLoader.onError = function ( error ) {
					console.log("Error OBJLoader : " + error);
				};
				objLoader.onProgress = function ( xhr ) {
					console.log("Objet: " + ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
				};

				// MTLLoader
				var mtlLoader = new MTLLoader(manager);
				mtlLoader.setPath( '/data/' );
				mtlLoader.onError = function ( error ) {
					console.log("Error MTLLoader : " + error);
				};
				mtlLoader.onProgress = function ( xhr ) {
					console.log("Texture: " + ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
				};

				// Terrain
				objLoader.load('_TerrainLod4.obj', function (obj) {
					terrain = obj;
					// enable shadows
					terrain.receiveShadow = true;
					terrain.castShadow = true;

					if (afficherAxes){
						var axesTerrain = new THREE.AxesHelper(100);
						terrain.add(axesTerrain);
					}


					// Rail droit
					mtlLoader.load( 'modifs/rail1.mtl', function ( materials ) {
						materials.preload();
						objLoader.setMaterials( materials )
								.load( 'rail1.obj', function ( obj ) {
									obj.traverse( function ( child ) {
										if (child.isMesh) {

											//console.log(child);
											geometryRail1.push(child.geometry);
											materialRail1.push(child.material);
										}
									});
									setupRails("rail1");

									// Rail tournant
									mtlLoader.load( 'modifs/rail2.mtl', function ( materials ) {
										materials.preload();
										objLoader.setMaterials(materials)
												.load('rail2.obj', function (obj) {
													//afin d'optimiser le nombre d'obj on savee dans 2 var le material et la geometry afin de creer des mesh sans creer d'autres obj ou clone
													obj.traverse(function (child) {
														if (child.isMesh) {

															//console.log(child);
															geometryRail2.push(child.geometry);
															materialRail2.push(child.material);
														}
													});
													setupRails("rail2");

													// Locomotive
													mtlLoader.load( 'modifs/resicza_loco.mtl', function ( materials ) {
														materials.preload();
														objLoader.setMaterials(materials)
																.load('resicza_loco.obj', function (obj) {
																	locomotive = obj;

																	locomotive.rotateX(90.0 * 2.0 * Math.PI / 360.0);
																	locomotive.scale.set(1.3, 1.3, 1.3);
																	locomotive.translateX(-100);
																	locomotive.translateZ(100);
																	locomotive.translateY(10.2);

																	// enable shadows
																	locomotive.receiveShadow = true;
																	locomotive.castShadow = true;


																	if (afficherAxes){
																		var axesLocomotive = new THREE.AxesHelper(200);
																		locomotive.add(axesLocomotive);
																	}


																	locoCreateLight();
																	tweenInit();
																	scene.add(locomotive);
																});
													});
												});
									});
								});
					});
				});
			}


			function locoCreateLight(){
				//feu droit
				var spotLightD = new THREE.SpotLight( 0xffffff/*couleur*/, 5/*intensite*/, 400/*distance*/, 0.3/*angle*/, 0.5/*penombre*/, 2/*decay*/);
				spotLightD.position.set( -9, 11/*hauteur*/, 42.5/*avant*/ );
				spotLightD.castShadow = true;
				spotLightD.target.position.x=-9;
				spotLightD.target.position.y=locomotive.position.y;
				spotLightD.target.position.z=locomotive.position.z+500;
				//création d'une boule pour savoir où est la lumiere
				var lightSphereD = new THREE.Mesh(new THREE.SphereBufferGeometry(0.5/*diametre*/,10/*nb segment width*/,10/*nb segment height*/),
						new THREE.MeshStandardMaterial({emissive: 0xffffff,emissiveIntensity: spotLightD.intensity} ) );
				lightSphereD.castShadow = true;
				spotLightD.add(lightSphereD);

				//feu gauche
				var spotLightG = new THREE.SpotLight( 0xffffff/*couleur*/, 5/*intensite*/, 400/*distance*/, 0.3/*angle*/, 0.5/*penombre*/, 2/*decay*/);
				spotLightG.position.set( 9, 11/*hauteur*/, 42.5/*avant*/ );
				spotLightG.castShadow = true;
				spotLightG.target.position.x=9;
				spotLightG.target.position.y=locomotive.position.y;
				spotLightG.target.position.z=locomotive.position.z+500;
				//création d'une boule pour savoir où est la lumiere
				var lightSphereG = new THREE.Mesh(new THREE.SphereBufferGeometry(0.5/*diametre*/,10/*nb segment width*/,10/*nb segment height*/),
						new THREE.MeshStandardMaterial({emissive: 0xffffff,emissiveIntensity: spotLightG.intensity} ) );
				lightSphereG.castShadow = true;
				spotLightG.add(lightSphereG);



				locomotive.add( spotLightD.target, spotLightG.target );
				locomotive.add(spotLightD, spotLightG);
			}



			function initRails(rail){
				rail.rotateX(90.0 * 2.0 * Math.PI / 360.0);
				rail.scale.set(0.1, 0.1, 0.1);
				rail.translateY(10.0);

				//on ajoute tous les sous objets de chaque rails
				if(rail.geometry === geometryRail1[0]){
					for (let i = 0; i < geometryRail1.length; i++) {
						rail.add( new THREE.Mesh(geometryRail1[i], materialRail1[i]) );
					}
				}
				if(rail.geometry === geometryRail2[0]){
					for (let i = 0; i < geometryRail2.length; i++) {
						rail.add( new THREE.Mesh(geometryRail2[i], materialRail2[i]) );
					}
				}
				// enable shadows
				rail.receiveShadow = true;
				rail.castShadow = true;
				return rail;
			}
			function emplacementRails(rail,ry,x,y){
				rail.rotation.y=ry;
				rail.position.setX(x);//Math.round((x)*1000)/1000);
				rail.position.setY(y);//Math.round((y)*1000)/1000);
				return rail;
			}

			function setupRails(rail) {
				var i, i2=0, ligneDroite=0;
				var start = 0;
				var end = nbrRails[ligneDroite];
				//première ligne droite
				if (rail==="rail1"){
					for (i = start; i < end; i++) {
						//creation d'une new mesh pour chaque rail avec la geometry et le materiau de base
						rails1Tab[i] = initRails(new THREE.Mesh(geometryRail1[0], materialRail1[0]));
						//incrémentation de la position en fonction du dernier rail de la ligne précédente (et rotation en y si besoin)
						rails1Tab[i]=emplacementRails(
								rails1Tab[i],//rail
								0,//rotation.y
								-100,//x
								-70-i*30);//y
						//affichage
						scene.add(rails1Tab[i]);
					}
				}
				// 1er virage
				if (rail==="rail2"){
					i2++;
					//creation d'une new mesh pour chaque rail avec la geometry et le materiau de base
					rails2Tab[i2] = initRails(new THREE.Mesh(geometryRail2[0], materialRail2[0]));
					// rotation pour le mettre dans le bon sens + position en fonction du dernier de la ligne droite précédente
					rails2Tab[i2]=emplacementRails(
							rails2Tab[i2],//rail
							-Math.PI/2.0,//rotation.y
							rails1Tab[end-1].position.x-11.25,//x
							rails1Tab[end-1].position.y-33);//y
					//affichage
					scene.add(rails2Tab[i2]);
				}

				ligneDroite++;
				start = end;
				end += nbrRails[ligneDroite];
				if (rail==="rail1"){
					for (i = start; i < end; i++) {
						rails1Tab[i] = initRails(new THREE.Mesh(geometryRail1[0], materialRail1[0]));
						rails1Tab[i]=emplacementRails(
								rails1Tab[i],//rail
								rails1Tab[start-1].rotation.y-Math.PI/2.0,//rotation.y
								rails1Tab[start-1].position.x-(i-start+1)*30-15.05,//x
								rails1Tab[start-1].position.y-30-14.8);//y
						scene.add(rails1Tab[i]);
					}
				}
				// 2eme virage
				if (rail==="rail2"){
					i2++;
					rails2Tab[i2] = initRails(new THREE.Mesh(geometryRail2[0], materialRail2[0]));
					rails2Tab[i2]=emplacementRails(
							rails2Tab[i2],//rail
							-Math.PI,//rotation.y
							rails1Tab[end-1].position.x-33,//x
							rails1Tab[end-1].position.y+11.25);//y
					scene.add(rails2Tab[i2]);
				}

				ligneDroite++;
				start = end;
				end += nbrRails[ligneDroite];
				if (rail==="rail1"){
					for (i = start; i < end; i++) {
						rails1Tab[i] = initRails(new THREE.Mesh(geometryRail1[0], materialRail1[0]));
						rails1Tab[i]=emplacementRails(
								rails1Tab[i],//rail
								rails1Tab[start-1].rotation.y-Math.PI/2.0,//rotation.y
								rails1Tab[start-1].position.x-30-14.75,//x
								rails1Tab[start-1].position.y+(i+1-start)*30+14.75);//y
						scene.add(rails1Tab[i]);
					}
				}
				// 3eme virage
				if(rail==="rail2"){
					i2++;
					rails2Tab[i2] = initRails(new THREE.Mesh(geometryRail2[0], materialRail2[0]));
					rails2Tab[i2]=emplacementRails(
							rails2Tab[i2],//rail
							0,//rotation.y
							rails1Tab[end-1].position.x-11.25,//x
							rails1Tab[end-1].position.y+34);//y
					scene.add(rails2Tab[i2]);
				}

				ligneDroite++;
				start = end;
				end += nbrRails[ligneDroite];
				if (rail==="rail1"){
					for (i = start; i < end; i++) {
						rails1Tab[i] = initRails(new THREE.Mesh(geometryRail1[0], materialRail1[0]));
						rails1Tab[i]=emplacementRails(
								rails1Tab[i],//rail
								rails1Tab[start-1].rotation.y+Math.PI/2.0,//rotation.y
								rails1Tab[start-1].position.x-(i+1-start)*30-15,//x
								rails1Tab[start-1].position.y+30+15.25);//y
						scene.add(rails1Tab[i]);
					}
				}
				// 4eme virage
				if (rail==="rail2"){
					i2++;
					rails2Tab[i2] = initRails(new THREE.Mesh(geometryRail2[0], materialRail2[0]));
					rails2Tab[i2]=emplacementRails(
							rails2Tab[i2],//rail
							-Math.PI,//rotation.y
							rails1Tab[end-1].position.x-33,//x
							rails1Tab[end-1].position.y+11.25);//y
					scene.add(rails2Tab[i2]);
				}

				ligneDroite++;
				start = end;
				end += nbrRails[ligneDroite];
				if (rail==="rail1"){
					for (i = start; i < end; i++) {
						rails1Tab[i] = initRails(new THREE.Mesh(geometryRail1[0], materialRail1[0]));
						rails1Tab[i]=emplacementRails(
								rails1Tab[i],//rail
								rails1Tab[start-1].rotation.y-Math.PI/2.0,//rotation.y
								rails1Tab[start-1].position.x-30-14.75,//x
								rails1Tab[start-1].position.y+(i+1-start)*30+14.75);//y
						scene.add(rails1Tab[i]);
					}
				}
				// 5eme virage
				if (rail==="rail2"){
					i2++;
					rails2Tab[i2] = initRails(new THREE.Mesh(geometryRail2[0], materialRail2[0]));
					rails2Tab[i2]=emplacementRails(
							rails2Tab[i2],//rail
							Math.PI/2,//rotation.y
							rails1Tab[end-1].position.x+11.25,//x
							rails1Tab[end-1].position.y+33);//y
					scene.add(rails2Tab[i2]);
				}
				ligneDroite++;
				start = end;
				end += nbrRails[ligneDroite];
				if (rail==="rail1"){
					for (i = start; i < end; i++) {
						rails1Tab[i] = initRails(new THREE.Mesh(geometryRail1[0], materialRail1[0]));
						rails1Tab[i]=emplacementRails(
								rails1Tab[i],//rail
								rails1Tab[start-1].rotation.y-Math.PI/2.0,//rotation.y
								rails1Tab[start-1].position.x+(i-start+1)*30+14.7,//x
								rails1Tab[start-1].position.y+30+15);//y
						scene.add(rails1Tab[i]);
					}
				}
				// 6eme virage
				if (rail==="rail2"){
					i2++;
					rails2Tab[i2] = initRails(new THREE.Mesh(geometryRail2[0], materialRail2[0]));
					rails2Tab[i2]=emplacementRails(
							rails2Tab[i2],//rail
							-Math.PI/2,//rotation.y
							rails1Tab[end-1].position.x+34,//x
							rails1Tab[end-1].position.y+11.25);//y
					scene.add(rails2Tab[i2]);
				}

				ligneDroite++;
				start = end;
				end += nbrRails[ligneDroite];
				if (rail==="rail1"){
					for (i = start; i < end; i++) {
						rails1Tab[i] = initRails(new THREE.Mesh(geometryRail1[0], materialRail1[0]));
						rails1Tab[i]=emplacementRails(
								rails1Tab[i],//rail
								rails1Tab[start-1].rotation.y+Math.PI/2.0,//rotation.y
								rails1Tab[start-1].position.x+30+14.9,//x
								rails1Tab[start-1].position.y+(i+1-start)*30+14.75);//y
						scene.add(rails1Tab[i]);
					}
				}
				// 7eme virage
				if (rail==="rail2"){
					i2++;
					rails2Tab[i2] = initRails(new THREE.Mesh(geometryRail2[0], materialRail2[0]));
					rails2Tab[i2]=emplacementRails(
							rails2Tab[i2],//rail
							Math.PI/2,//rotation.y
							rails1Tab[end-1].position.x+11.25,//x
							rails1Tab[end-1].position.y+33);//y
					scene.add(rails2Tab[i2]);
				}
				ligneDroite++;
				start = end;
				end += nbrRails[ligneDroite];
				if (rail==="rail1"){
					for (i = start; i < end; i++) {
						rails1Tab[i] = initRails(new THREE.Mesh(geometryRail1[0], materialRail1[0]));
						rails1Tab[i]=emplacementRails(
								rails1Tab[i],//rail
								rails1Tab[start-1].rotation.y-Math.PI/2.0,//rotation.y
								rails1Tab[start-1].position.x+(i-start+1)*30+14.7,//x
								rails1Tab[start-1].position.y+30+15);//y
						scene.add(rails1Tab[i]);
					}
				}
				// 8eme virage
				if (rail==="rail2"){
					i2++;
					rails2Tab[i2] = initRails(new THREE.Mesh(geometryRail2[0], materialRail2[0]));
					rails2Tab[i2]=emplacementRails(
							rails2Tab[i2],//rail
							0,//rotation.y
							rails1Tab[end-1].position.x+33,//x
							rails1Tab[end-1].position.y-11.25);//y
					scene.add(rails2Tab[i2]);
				}
				ligneDroite++;
				start = end;
				end += nbrRails[ligneDroite];
				if (rail==="rail1"){
					for (i = start; i < end; i++) {
						rails1Tab[i] = initRails(new THREE.Mesh(geometryRail1[0], materialRail1[0]));
						rails1Tab[i]=emplacementRails(
								rails1Tab[i],//rail
								rails1Tab[start-1].rotation.y-Math.PI/2.0,//rotation.y
								rails1Tab[start-1].position.x+30+14.9,//x
								rails1Tab[start-1].position.y-(i+1-start)*30-14.5);//y
						scene.add(rails1Tab[i]);
					}
				}
				// 9eme virage
				if (rail==="rail2"){
					i2++;
					rails2Tab[i2] = initRails(new THREE.Mesh(geometryRail2[0], materialRail2[0]));
					rails2Tab[i2]=emplacementRails(
							rails2Tab[i2],//rail
							Math.PI,//rotation.y
							rails1Tab[end-1].position.x+11.25,//x
							rails1Tab[end-1].position.y-33.5);//y
					scene.add(rails2Tab[i2]);
				}

				ligneDroite++;
				start = end;
				end += nbrRails[ligneDroite];
				if (rail==="rail1"){
					for (i = start; i < end; i++) {
						rails1Tab[i] = initRails(new THREE.Mesh(geometryRail1[0], materialRail1[0]));
						rails1Tab[i]=emplacementRails(
								rails1Tab[i],//rail
								rails1Tab[start-1].rotation.y+Math.PI/2.0,//rotation.y
								rails1Tab[start-1].position.x+(i-start+1)*30+14.7,//x
								rails1Tab[start-1].position.y-30-14.5);//y
						scene.add(rails1Tab[i]);
					}
				}
				// 10eme virage
				if (rail==="rail2"){
					i2++;
					rails2Tab[i2] = initRails(new THREE.Mesh(geometryRail2[0], materialRail2[0]));
					rails2Tab[i2]=emplacementRails(
							rails2Tab[i2],//rail
							0,//rotation.y
							rails1Tab[end-1].position.x+33,//x
							rails1Tab[end-1].position.y-11.25);//y
					scene.add(rails2Tab[i2]);
				}

				ligneDroite++;
				start = end;
				end += nbrRails[ligneDroite];
				if (rail==="rail1"){
					for (i = start; i < end; i++) {
						rails1Tab[i] = initRails(new THREE.Mesh(geometryRail1[0], materialRail1[0]));
						rails1Tab[i]=emplacementRails(
								rails1Tab[i],//rail
								rails1Tab[start-1].rotation.y-Math.PI/2.0,//rotation.y
								rails1Tab[start-1].position.x+30+14.9,//x
								rails1Tab[start-1].position.y-(i+1-start)*30-15);//y
						scene.add(rails1Tab[i]);
					}
				}
				// 11eme virage
				if (rail==="rail2"){
					i2++;
					rails2Tab[i2] = initRails(new THREE.Mesh(geometryRail2[0], materialRail2[0]));
					rails2Tab[i2]=emplacementRails(
							rails2Tab[i2],//rail
							-Math.PI/2.0,//rotation.y
							rails1Tab[end-1].position.x-11.25,//x
							rails1Tab[end-1].position.y-33);//y
					scene.add(rails2Tab[i2]);
				}
				// 12eme virage
				if (rail==="rail2"){
					i2++;
					rails2Tab[i2] = initRails(new THREE.Mesh(geometryRail2[0], materialRail2[0]));
					rails2Tab[i2]=emplacementRails(
							rails2Tab[i2],//rail
							Math.PI/2.0,//rotation.y
							rails1Tab[end-1].position.x-38-11.25,//x
							rails1Tab[end-1].position.y-23-33);//y
					scene.add(rails2Tab[i2]);
				}
				ligneDroite++;
				start = end;
				end += nbrRails[ligneDroite];
				if (rail==="rail1"){
					for (i = start; i < end; i++) {
						rails1Tab[i] = initRails(new THREE.Mesh(geometryRail1[0], materialRail1[0]));
						rails1Tab[i]=emplacementRails(
								rails1Tab[i],//rail
								rails1Tab[start-1].rotation.y,//rotation.y
								rails1Tab[start-1].position.x-30-30,//x
								rails1Tab[start-1].position.y-(i+1-start)*30-2*30);//y
						scene.add(rails1Tab[i]);
					}
				}
				// 13eme virage
				if (rail==="rail2"){
					i2++;
					rails2Tab[i2] = initRails(new THREE.Mesh(geometryRail2[0], materialRail2[0]));
					rails2Tab[i2]=emplacementRails(
							rails2Tab[i2],//rail
							-Math.PI/2.0,//rotation.y
							rails1Tab[end-1].position.x-11.25,//x
							rails1Tab[end-1].position.y-33);//y
					scene.add(rails2Tab[i2]);
				}

				ligneDroite++;
				start = end;
				end += nbrRails[ligneDroite];
				if (rail==="rail1"){
					for (i = start; i < end; i++) {
						rails1Tab[i] = initRails(new THREE.Mesh(geometryRail1[0], materialRail1[0]));
						rails1Tab[i]=emplacementRails(
								rails1Tab[i],//rail
								rails1Tab[start-1].rotation.y-Math.PI/2.0,//rotation.y
								rails1Tab[start-1].position.x-(i-start+1)*30-15,//x
								rails1Tab[start-1].position.y-30-14.81);//y
						scene.add(rails1Tab[i]);
					}
				}
				// 14eme virage (au centre)
				if (rail==="rail2"){
					i2++;
					rails2Tab[i2] = initRails(new THREE.Mesh(geometryRail2[0], materialRail2[0]));
					rails2Tab[i2]=emplacementRails(
							rails2Tab[i2],//rail
							Math.PI/2.0,//rotation.y
							rails1Tab[end-1].position.x-33.5,//x
							rails1Tab[end-1].position.y-11.25);//y
					scene.add(rails2Tab[i2]);
				}

				// ajout des axes
				if (rail==="rail1" && afficherAxes){
					rails1Tab.forEach((rail1Tab) => {
						rail1Tab.add(new THREE.AxesHelper(500));
					});
				}
				// ajout des axes
				if (rail==="rail2" && afficherAxes){
					rails2Tab.forEach((rail2Tab) => {
						rail2Tab.add(new THREE.AxesHelper(500));
					});
				}

			}
			var vitesseTween = 500;
			var doubleRailOk = false;
			var numRailDouble = nbrTotalRails-nbrRails[nbrRails.length-1]-nbrRails[nbrRails.length-2];
			var rotationLoco = 0;
			function animateLocomotive() {
				if (locomotive){
					if(rails1Tab[numRail]) {
						//console.log("loco : " + locomotive.position.x + "; " + locomotive.position.y);
						//console.log("rail_"+numRail+" : " + rails1Tab[numRail].position.x + "; " + rails1Tab[numRail].position.y);
						if(locomotive.position.x === target1.x &&
								locomotive.position.y === target1.y){

							// go to next rail
							numRail++;
							if (numRail>=nbrTotalRails){
								//retour à zero
								numRail=0;
								//on incremente à chaque tour de -2PI car on tourne en rond
								rotationLoco+=-2*Math.PI;
							}

							if(!doubleRailOk && numRail===numRailDouble){
								target1 = { x : (rails1Tab[numRail].position.x+rails1Tab[numRail-1].position.x)/2, y: (rails1Tab[numRail].position.y+rails1Tab[numRail-1].position.y)/2 , rotation : (rotationLoco-5*Math.PI/2.0)};
								doubleRailOk=true;
								// go to next rail
								numRail--;
								//console.log("double rail, "+rails1Tab[numRail].rotation.y);
							}else if(numRail!==numRailDouble || (numRail===numRailDouble && doubleRailOk)){

								//console.log(numRail+", "+(rotationLoco+rails1Tab[numRail].rotation.y));
								target1 = { x : rails1Tab[numRail].position.x, y: rails1Tab[numRail].position.y , rotation : (rotationLoco+rails1Tab[numRail].rotation.y)};


								doubleRailOk=false;
							}
							tween.to(target1, vitesseTween);
							tween.start();
							//console.log("loco : " + locomotive.position.x + "; " + locomotive.position.y+"\n"
							//		+"next position : \n"
							//		+"rail_"+numRail+" : " + rails1Tab[numRail].position.x + "; " + rails1Tab[numRail].position.y);

						} else {
							TWEEN.update();
						}
					}
				}
			}

			function tweenInit(){
				target1 = { x : rails1Tab[numRail].position.x, y: rails1Tab[numRail].position.y , rotation : rails1Tab[numRail].rotation.y};
				var position = { x : 0, y: 0, rotation: 0 };

				tween = new TWEEN.Tween(position)
						.to(target1, vitesseTween)
						.onUpdate(function(){
							locomotive.position.x = position.x;
							locomotive.position.y = position.y;
							locomotive.rotation.y = position.rotation;
							//console.log("en mouvement : " + position.x + "; " + position.y);
						})
						.easing(TWEEN.Easing.Linear.None)
						.start();
			}

			function animate(time) {
				animateLocomotive();

				//changement position soleil
				if(light){
					light.position.x=Math.cos(time/1000)*1000;
					light.position.z=Math.sin(time/1000)*1000;
				}

				controls.update();
				render();
				requestAnimationFrame( animate );
			}

			function render() {
				renderer.render(scene, camera);
			}

			// gestion redimensionnement fenetre
			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);
			}

		</script>
	</body>
</html>