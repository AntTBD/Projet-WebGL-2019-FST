<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>Projet WebGL 2019 - Université de Limoges</title>

		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>

	<body>
		<div id="info">
			Projet WebGL 2019 - Université de Limoges - Jonas FRANCESHI - Martin MORAND - Antoine TABARAUD
		</div>
		<script language="javascript">
			var derniereModif=document.lastModified;
			var dateModif = new Date(derniereModif);
			console.log("Dernière modification le "+dateModif);
		</script>
<!--		<script src="./threejs/Tween.min.js"></script>-->
		<script src="./tween/tween.umd.js"></script>
		<script type="module">
			import * as THREE from './threejs/three.module.js';
			import { MTLLoader } from './threejs/MTLLoader.js';
			import { OBJLoader } from './threejs/OBJLoader.js';
			import { TrackballControls } from './threejs/TrackballControls.js';

			var debug=false;
			var debugSecondaire=false;

			var container;

			var camera, scene, renderer, controls, light;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			var object;

			var /*rail1, rail2,*/ terrain, locomotive;
			var geometryRail1=[], geometryRail2=[];
			var materialRail1=[], materialRail2=[];

			//afficher ou non les axes des différents objets
			var afficherAxes = false;

			//stockage des rails
			var rails1Tab = [];
			var rails2Tab = [];
			//nombre de rail dans chaque ligne droite
			var nbrRails = [20, 11, 14, 7, 25, 6, 4, 23, 4, 13, 12, 5, 22];
			//calcul du nombre total de rails (utilisé dans l'animation locomotive)
			var nbrTotalRails=0;
			for (let i = 0; i < nbrRails.length; i++) {
				nbrTotalRails+=nbrRails[i];
			}
			if(debugSecondaire) {
				console.log("nb total de rail1: "+nbrTotalRails);
			}


			// animation train
			//deplacement train
			var tween;
			var target;
			var numRail = 0;
			//parametre pour le deplacement
			var vitesseTween = 1000;
			var doubleRailOk = false;
			var numRailDouble = nbrTotalRails-nbrRails[nbrRails.length-1]-nbrRails[nbrRails.length-2];
			var rotationTour = 0;
			//lights
			var allumerLumieres=false;
			var spotLightLocoD, spotLightLocoG;



			//premier lancement
			init();


			function init() {
				container = document.createElement('div');
				document.body.appendChild(container);

				// scene
				scene = new THREE.Scene();

				if(afficherAxes){
					var axesScene = new THREE.AxesHelper(100);
					scene.add(axesScene);
				}

				if(debug) {
					console.log("Scene ok");
				}

				createRenderer();
				createCamera();
				createControls();
				createLights();
				loadModels();

				animate(new Date().getTime());

				// gestion redimensionnement fenetre
				window.addEventListener( 'resize', onWindowResize, false );

				if(debug) {
					console.log("------------- INIT OK -------------");
				}
			}

			// creation renderer
			function createRenderer() {
				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setClearColor(0xAAAAAA, 1);
				renderer.shadowMap.enabled = true;
				container.appendChild(renderer.domElement);
				if(debug) {
					console.log("Renderer ok");
				}
			}

			// camera
			function createCamera() {
				camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 4000);
				camera.position.z = 700;
				camera.position.y = -1100;

				camera.lookAt(0, 0, 0);
				scene.add(camera);
				if(debug) {
					console.log("Camera ok");
				}
			}

			function createControls() {
				// controle sur la camera, type trackball
				controls = new TrackballControls(camera, renderer.domElement);
				if(debug) {
					console.log("Controls ok");
				}
			}

			// lights
			function createLights() {
				light = new THREE.PointLight(0xFFFFFF, 1.0);
				light.position.set(0, -500, 500);
				// enable shadows
				light.receiveShadow = true;
				light.castShadow = true;
				scene.add(light);

				//création d'une boule pour savoir où est la lumiere
				var lightSphere = new THREE.Mesh(new THREE.SphereBufferGeometry(50,20,20),
						new THREE.MeshStandardMaterial({emissive: 0xffffff,emissiveIntensity: light.intensity} ) );
				lightSphere.castShadow = true;
				light.add(lightSphere);

				if(debug) {
					console.log("Soleil ok");
				}
			}


			// load all models
			function loadModels() {

				// http://www.smartjava.org/content/render-3d-star-wars-force-awakens-models-blender-and-threejs/
				var textLoader = new THREE.TextureLoader();
				var diffuseTexture = textLoader.load("data/textures/Terrain/diffuse.png");
				var bumpTexture = textLoader.load("data/textures/Terrain/flows.png");
				var emissiveTexture = textLoader.load("data/textures/Terrain/hight.png");//montagnes (color white)
				//var specularTexture = textLoader.load("data/textures/Terrain/flows.png");

				function loadModel() {
					terrain.traverse(function (child) {
						if (child.isMesh){
							// http://www.smartjava.org/content/render-3d-star-wars-force-awakens-models-blender-and-threejs/
							var material = child.material;

							// basic texture
							material.map = diffuseTexture;


							// bumps (carte de niveau de hauteur à bas relief) perturbation de normal
					//		material.bumpMap = bumpTexture;
					//		material.bumpScale = -1.0;


							// glow
					//		material.emissive = new THREE.Color(0xffffff);//couleur blanche pour la neige
					//		material.emissiveMap = emissiveTexture;
							//material.emissive = new THREE.Color(0x0083ff);//couleur blanche pour la neige
							//material.emissiveMap = bumpTexture;

							// specular (relief)
							//material.specularMap = bumpTexture;

						}
					});

					scene.add(terrain);
					if(debug) {
						console.log("terrain ok");
					}

				}

				// LoadingManager
				var manager = new THREE.LoadingManager(loadModel);
				manager.onStart = function ( item, loaded, total ) {
					if(debug) {
						console.log( 'Started loading file: ' + item + '.\nLoaded ' + loaded + ' of ' + total + ' files.' );
					}
				};
				manager.onProgress = function (item, loaded, total) {
					if(debug) {
						console.log("Load:", item, "(", loaded, "/", total, ")");
					}
				};
				manager.onError = function ( error ) {
					console.log( 'There was an error loading : ' + error );
				};



				// OBJLoader
				var objLoader = new OBJLoader(manager)
						.setPath( '/data/modifs/' );
				objLoader.onError = function ( error ) {
					console.log("Error OBJLoader : " + error);
				};
				objLoader.onProgress = function ( xhr ) {
					if(debug) {
						console.log("Objet: " + ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
					}
				};

				// MTLLoader
				var mtlLoader = new MTLLoader(manager);
				mtlLoader.setPath( '/data/' );
				mtlLoader.onError = function ( error ) {
					console.log("Error MTLLoader : " + error);
				};
				mtlLoader.onProgress = function ( xhr ) {
					if(debug) {
						console.log("Texture: " + ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
					}
				};

				// Terrain
				objLoader.load('_TerrainLod4.obj', function (obj) {
					terrain = obj;
					// enable shadows
					terrain.receiveShadow = true;
					terrain.castShadow = true;

					if (afficherAxes){
						var axesTerrain = new THREE.AxesHelper(100);
						terrain.add(axesTerrain);
					}


					// Rail droit
					mtlLoader.load( 'modifs/rail1.mtl', function ( materials ) {
						materials.preload();
						objLoader.setMaterials( materials )
								.load( 'rail1.obj', function ( obj ) {
									obj.traverse( function ( child ) {
										if (child.isMesh) {

											//console.log(child);
											geometryRail1.push(child.geometry);
											materialRail1.push(child.material);
										}
									});
									setupRails("rail1");
									if(debug) {
										console.log("rails droits ok");
									}

									// Rail tournant
									mtlLoader.load( 'modifs/rail2.mtl', function ( materials ) {
										materials.preload();
										objLoader.setMaterials(materials)
												.load('rail2.obj', function (obj) {
													//afin d'optimiser le nombre d'obj on savee dans 2 var le material et la geometry afin de creer des mesh sans creer d'autres obj ou clone
													obj.traverse(function (child) {
														if (child.isMesh) {

															//console.log(child);
															geometryRail2.push(child.geometry);
															materialRail2.push(child.material);
														}
													});
													setupRails("rail2");
													if(debug) {
														console.log("rails tournants ok");
													}

													// Locomotive
													mtlLoader.load( 'modifs/resicza_loco.mtl', function ( materials ) {
														materials.preload();
														objLoader.setMaterials(materials)
																.load('resicza_loco.obj', function (obj) {
																	locomotive = obj;

																	locomotive.rotateX(90.0 * 2.0 * Math.PI / 360.0);
																	locomotive.scale.set(1.3, 1.3, 1.3);
																	locomotive.translateX(-100);
																	locomotive.translateZ(100);
																	locomotive.translateY(10.2);


																	// enable shadows
																	locomotive.receiveShadow = true;
																	locomotive.castShadow = true;


																	if (afficherAxes){
																		var axesLocomotive = new THREE.AxesHelper(200);
																		locomotive.add(axesLocomotive);
																	}


																	locoCreateLight();
																	tweenInit();
																	scene.add(locomotive);
																	if(debug) {
																		console.log("Locomotive ok");
																	}
																});
													});
												});
									});
								});
					});
				});
			}


			function locoCreateLight(){
				//feu droit
				spotLightLocoD = new THREE.SpotLight( 0xffffff/*couleur*/, 5/*intensite*/, 400/*distance*/, 0.3/*angle*/, 0.5/*penombre*/, 2/*decay*/);
				spotLightLocoD.position.set( -9, 11/*hauteur*/, 42.5/*avant*/ );
				spotLightLocoD.castShadow = true;
				spotLightLocoD.target.position.x=-9;
				spotLightLocoD.target.position.y=locomotive.position.y;
				spotLightLocoD.target.position.z=locomotive.position.z+500;
				//création d'une boule pour savoir où est la lumiere
				var lightSphereD = new THREE.Mesh(new THREE.SphereBufferGeometry(0.5/*diametre*/,10/*nb segment width*/,10/*nb segment height*/),
						new THREE.MeshStandardMaterial({emissive: 0xffffff,emissiveIntensity: spotLightLocoD.intensity} ) );
				lightSphereD.castShadow = true;
				spotLightLocoD.add(lightSphereD);

				//feu gauche
				spotLightLocoG = new THREE.SpotLight( 0xffffff/*couleur*/, 5/*intensite*/, 400/*distance*/, 0.3/*angle*/, 0.5/*penombre*/, 2/*decay*/);
				spotLightLocoG.position.set( 9, 11/*hauteur*/, 42.5/*avant*/ );
				spotLightLocoG.castShadow = true;
				spotLightLocoG.target.position.x=9;
				spotLightLocoG.target.position.y=locomotive.position.y;
				spotLightLocoG.target.position.z=locomotive.position.z+500;
				//création d'une boule pour savoir où est la lumiere
				var lightSphereG = new THREE.Mesh(new THREE.SphereBufferGeometry(0.5/*diametre*/,10/*nb segment width*/,10/*nb segment height*/),
						new THREE.MeshStandardMaterial({emissive: 0xffffff,emissiveIntensity: spotLightLocoG.intensity} ) );
				lightSphereG.castShadow = true;
				spotLightLocoG.add(lightSphereG);



				locomotive.add( spotLightLocoD.target, spotLightLocoG.target );
				locomotive.add(spotLightLocoD, spotLightLocoG);

				if(debug) {
					console.log("phare locomotive ok");
				}
			}



			function initRails(rail){
				rail.rotateX(90.0 * 2.0 * Math.PI / 360.0);
				rail.scale.set(0.1, 0.1, 0.1);
				rail.translateY(10.0);

				//on ajoute tous les sous objets de chaque rails
				if(rail.geometry === geometryRail1[0]){
					for (let i = 0; i < geometryRail1.length; i++) {
						rail.add( new THREE.Mesh(geometryRail1[i], materialRail1[i]) );
					}
				}
				if(rail.geometry === geometryRail2[0]){
					for (let i = 0; i < geometryRail2.length; i++) {
						rail.add( new THREE.Mesh(geometryRail2[i], materialRail2[i]) );
					}
				}
				// enable shadows
				rail.receiveShadow = true;
				rail.castShadow = true;

				return rail;
			}
			function emplacementRails(rail,ry,x,y){
				rail.rotation.y=ry;
				rail.position.setX(Math.round((x)*1000)/1000);//arrondi à 0.001 près
				rail.position.setY(Math.round((y)*1000)/1000);//arrondi à 0.001 près
				return rail;
			}

			function setupRails(rail) {
				var i, i2=0, ligneDroite=0;
				var start = 0;
				var end = nbrRails[ligneDroite];
				//première ligne droite
				if (rail==="rail1"){
					for (i = start; i < end; i++) {
						//creation d'une new mesh pour chaque rail avec la geometry et le materiau de base
						rails1Tab[i] = initRails(new THREE.Mesh(geometryRail1[0], materialRail1[0]));
						//incrémentation de la position en fonction du dernier rail de la ligne précédente (et rotation en y si besoin)
						rails1Tab[i]=emplacementRails(
								rails1Tab[i],//rail
								0,//rotation.y
								-100,//x
								-70-i*30);//y
						//affichage
						scene.add(rails1Tab[i]);
					}
				}
				// 1er virage
				if (rail==="rail2"){
					i2++;
					//creation d'une new mesh pour chaque rail avec la geometry et le materiau de base
					rails2Tab[i2] = initRails(new THREE.Mesh(geometryRail2[0], materialRail2[0]));
					// rotation pour le mettre dans le bon sens + position en fonction du dernier de la ligne droite précédente
					rails2Tab[i2]=emplacementRails(
							rails2Tab[i2],//rail
							-Math.PI/2.0,//rotation.y
							rails1Tab[end-1].position.x-11.25,//x
							rails1Tab[end-1].position.y-33);//y
					//affichage
					scene.add(rails2Tab[i2]);
				}

				ligneDroite++;
				start = end;
				end += nbrRails[ligneDroite];
				if (rail==="rail1"){
					for (i = start; i < end; i++) {
						rails1Tab[i] = initRails(new THREE.Mesh(geometryRail1[0], materialRail1[0]));
						rails1Tab[i]=emplacementRails(
								rails1Tab[i],//rail
								rails1Tab[start-1].rotation.y-Math.PI/2.0,//rotation.y
								rails1Tab[start-1].position.x-(i-start+1)*30-15.05,//x
								rails1Tab[start-1].position.y-30-14.8);//y
						scene.add(rails1Tab[i]);
					}
				}
				// 2eme virage
				if (rail==="rail2"){
					i2++;
					rails2Tab[i2] = initRails(new THREE.Mesh(geometryRail2[0], materialRail2[0]));
					rails2Tab[i2]=emplacementRails(
							rails2Tab[i2],//rail
							-Math.PI,//rotation.y
							rails1Tab[end-1].position.x-33,//x
							rails1Tab[end-1].position.y+11.25);//y
					scene.add(rails2Tab[i2]);
				}

				ligneDroite++;
				start = end;
				end += nbrRails[ligneDroite];
				if (rail==="rail1"){
					for (i = start; i < end; i++) {
						rails1Tab[i] = initRails(new THREE.Mesh(geometryRail1[0], materialRail1[0]));
						rails1Tab[i]=emplacementRails(
								rails1Tab[i],//rail
								rails1Tab[start-1].rotation.y-Math.PI/2.0,//rotation.y
								rails1Tab[start-1].position.x-30-14.75,//x
								rails1Tab[start-1].position.y+(i+1-start)*30+14.75);//y
						scene.add(rails1Tab[i]);
					}
				}
				// 3eme virage
				if(rail==="rail2"){
					i2++;
					rails2Tab[i2] = initRails(new THREE.Mesh(geometryRail2[0], materialRail2[0]));
					rails2Tab[i2]=emplacementRails(
							rails2Tab[i2],//rail
							0,//rotation.y
							rails1Tab[end-1].position.x-11.25,//x
							rails1Tab[end-1].position.y+34);//y
					scene.add(rails2Tab[i2]);
				}

				ligneDroite++;
				start = end;
				end += nbrRails[ligneDroite];
				if (rail==="rail1"){
					for (i = start; i < end; i++) {
						rails1Tab[i] = initRails(new THREE.Mesh(geometryRail1[0], materialRail1[0]));
						rails1Tab[i]=emplacementRails(
								rails1Tab[i],//rail
								rails1Tab[start-1].rotation.y+Math.PI/2.0,//rotation.y
								rails1Tab[start-1].position.x-(i+1-start)*30-15,//x
								rails1Tab[start-1].position.y+30+15.25);//y
						scene.add(rails1Tab[i]);
					}
				}
				// 4eme virage
				if (rail==="rail2"){
					i2++;
					rails2Tab[i2] = initRails(new THREE.Mesh(geometryRail2[0], materialRail2[0]));
					rails2Tab[i2]=emplacementRails(
							rails2Tab[i2],//rail
							-Math.PI,//rotation.y
							rails1Tab[end-1].position.x-33,//x
							rails1Tab[end-1].position.y+11.25);//y
					scene.add(rails2Tab[i2]);
				}

				ligneDroite++;
				start = end;
				end += nbrRails[ligneDroite];
				if (rail==="rail1"){
					for (i = start; i < end; i++) {
						rails1Tab[i] = initRails(new THREE.Mesh(geometryRail1[0], materialRail1[0]));
						rails1Tab[i]=emplacementRails(
								rails1Tab[i],//rail
								rails1Tab[start-1].rotation.y-Math.PI/2.0,//rotation.y
								rails1Tab[start-1].position.x-30-14.75,//x
								rails1Tab[start-1].position.y+(i+1-start)*30+14.75);//y
						scene.add(rails1Tab[i]);
					}
				}
				// 5eme virage
				if (rail==="rail2"){
					i2++;
					rails2Tab[i2] = initRails(new THREE.Mesh(geometryRail2[0], materialRail2[0]));
					rails2Tab[i2]=emplacementRails(
							rails2Tab[i2],//rail
							Math.PI/2,//rotation.y
							rails1Tab[end-1].position.x+11.25,//x
							rails1Tab[end-1].position.y+33);//y
					scene.add(rails2Tab[i2]);
				}
				ligneDroite++;
				start = end;
				end += nbrRails[ligneDroite];
				if (rail==="rail1"){
					for (i = start; i < end; i++) {
						rails1Tab[i] = initRails(new THREE.Mesh(geometryRail1[0], materialRail1[0]));
						rails1Tab[i]=emplacementRails(
								rails1Tab[i],//rail
								rails1Tab[start-1].rotation.y-Math.PI/2.0,//rotation.y
								rails1Tab[start-1].position.x+(i-start+1)*30+14.7,//x
								rails1Tab[start-1].position.y+30+15);//y
						scene.add(rails1Tab[i]);
					}
				}
				// 6eme virage
				if (rail==="rail2"){
					i2++;
					rails2Tab[i2] = initRails(new THREE.Mesh(geometryRail2[0], materialRail2[0]));
					rails2Tab[i2]=emplacementRails(
							rails2Tab[i2],//rail
							-Math.PI/2,//rotation.y
							rails1Tab[end-1].position.x+34,//x
							rails1Tab[end-1].position.y+11.25);//y
					scene.add(rails2Tab[i2]);
				}

				ligneDroite++;
				start = end;
				end += nbrRails[ligneDroite];
				if (rail==="rail1"){
					for (i = start; i < end; i++) {
						rails1Tab[i] = initRails(new THREE.Mesh(geometryRail1[0], materialRail1[0]));
						rails1Tab[i]=emplacementRails(
								rails1Tab[i],//rail
								rails1Tab[start-1].rotation.y+Math.PI/2.0,//rotation.y
								rails1Tab[start-1].position.x+30+14.9,//x
								rails1Tab[start-1].position.y+(i+1-start)*30+14.75);//y
						scene.add(rails1Tab[i]);
					}
				}
				// 7eme virage
				if (rail==="rail2"){
					i2++;
					rails2Tab[i2] = initRails(new THREE.Mesh(geometryRail2[0], materialRail2[0]));
					rails2Tab[i2]=emplacementRails(
							rails2Tab[i2],//rail
							Math.PI/2,//rotation.y
							rails1Tab[end-1].position.x+11.25,//x
							rails1Tab[end-1].position.y+33);//y
					scene.add(rails2Tab[i2]);
				}
				ligneDroite++;
				start = end;
				end += nbrRails[ligneDroite];
				if (rail==="rail1"){
					for (i = start; i < end; i++) {
						rails1Tab[i] = initRails(new THREE.Mesh(geometryRail1[0], materialRail1[0]));
						rails1Tab[i]=emplacementRails(
								rails1Tab[i],//rail
								rails1Tab[start-1].rotation.y-Math.PI/2.0,//rotation.y
								rails1Tab[start-1].position.x+(i-start+1)*30+14.7,//x
								rails1Tab[start-1].position.y+30+15);//y
						scene.add(rails1Tab[i]);
					}
				}
				// 8eme virage
				if (rail==="rail2"){
					i2++;
					rails2Tab[i2] = initRails(new THREE.Mesh(geometryRail2[0], materialRail2[0]));
					rails2Tab[i2]=emplacementRails(
							rails2Tab[i2],//rail
							0,//rotation.y
							rails1Tab[end-1].position.x+33,//x
							rails1Tab[end-1].position.y-11.25);//y
					scene.add(rails2Tab[i2]);
				}
				ligneDroite++;
				start = end;
				end += nbrRails[ligneDroite];
				if (rail==="rail1"){
					for (i = start; i < end; i++) {
						rails1Tab[i] = initRails(new THREE.Mesh(geometryRail1[0], materialRail1[0]));
						rails1Tab[i]=emplacementRails(
								rails1Tab[i],//rail
								rails1Tab[start-1].rotation.y-Math.PI/2.0,//rotation.y
								rails1Tab[start-1].position.x+30+14.9,//x
								rails1Tab[start-1].position.y-(i+1-start)*30-14.5);//y
						scene.add(rails1Tab[i]);
					}
				}
				// 9eme virage
				if (rail==="rail2"){
					i2++;
					rails2Tab[i2] = initRails(new THREE.Mesh(geometryRail2[0], materialRail2[0]));
					rails2Tab[i2]=emplacementRails(
							rails2Tab[i2],//rail
							Math.PI,//rotation.y
							rails1Tab[end-1].position.x+11.25,//x
							rails1Tab[end-1].position.y-33.5);//y
					scene.add(rails2Tab[i2]);
				}

				ligneDroite++;
				start = end;
				end += nbrRails[ligneDroite];
				if (rail==="rail1"){
					for (i = start; i < end; i++) {
						rails1Tab[i] = initRails(new THREE.Mesh(geometryRail1[0], materialRail1[0]));
						rails1Tab[i]=emplacementRails(
								rails1Tab[i],//rail
								rails1Tab[start-1].rotation.y+Math.PI/2.0,//rotation.y
								rails1Tab[start-1].position.x+(i-start+1)*30+14.7,//x
								rails1Tab[start-1].position.y-30-14.5);//y
						scene.add(rails1Tab[i]);
					}
				}
				// 10eme virage
				if (rail==="rail2"){
					i2++;
					rails2Tab[i2] = initRails(new THREE.Mesh(geometryRail2[0], materialRail2[0]));
					rails2Tab[i2]=emplacementRails(
							rails2Tab[i2],//rail
							0,//rotation.y
							rails1Tab[end-1].position.x+33,//x
							rails1Tab[end-1].position.y-11.25);//y
					scene.add(rails2Tab[i2]);
				}

				ligneDroite++;
				start = end;
				end += nbrRails[ligneDroite];
				if (rail==="rail1"){
					for (i = start; i < end; i++) {
						rails1Tab[i] = initRails(new THREE.Mesh(geometryRail1[0], materialRail1[0]));
						rails1Tab[i]=emplacementRails(
								rails1Tab[i],//rail
								rails1Tab[start-1].rotation.y-Math.PI/2.0,//rotation.y
								rails1Tab[start-1].position.x+30+14.9,//x
								rails1Tab[start-1].position.y-(i+1-start)*30-15);//y
						scene.add(rails1Tab[i]);
					}
				}
				// 11eme virage
				if (rail==="rail2"){
					i2++;
					rails2Tab[i2] = initRails(new THREE.Mesh(geometryRail2[0], materialRail2[0]));
					rails2Tab[i2]=emplacementRails(
							rails2Tab[i2],//rail
							-Math.PI/2.0,//rotation.y
							rails1Tab[end-1].position.x-11.25,//x
							rails1Tab[end-1].position.y-33);//y
					scene.add(rails2Tab[i2]);
				}
				// 12eme virage
				if (rail==="rail2"){
					i2++;
					rails2Tab[i2] = initRails(new THREE.Mesh(geometryRail2[0], materialRail2[0]));
					rails2Tab[i2]=emplacementRails(
							rails2Tab[i2],//rail
							Math.PI/2.0,//rotation.y
							rails1Tab[end-1].position.x-38-11.25,//x
							rails1Tab[end-1].position.y-23-33);//y
					scene.add(rails2Tab[i2]);
				}
				ligneDroite++;
				start = end;
				end += nbrRails[ligneDroite];
				if (rail==="rail1"){
					for (i = start; i < end; i++) {
						rails1Tab[i] = initRails(new THREE.Mesh(geometryRail1[0], materialRail1[0]));
						rails1Tab[i]=emplacementRails(
								rails1Tab[i],//rail
								rails1Tab[start-1].rotation.y,//rotation.y
								rails1Tab[start-1].position.x-30-30,//x
								rails1Tab[start-1].position.y-(i+1-start)*30-2*30);//y
						scene.add(rails1Tab[i]);
					}
				}
				// 13eme virage
				if (rail==="rail2"){
					i2++;
					rails2Tab[i2] = initRails(new THREE.Mesh(geometryRail2[0], materialRail2[0]));
					rails2Tab[i2]=emplacementRails(
							rails2Tab[i2],//rail
							-Math.PI/2.0,//rotation.y
							rails1Tab[end-1].position.x-11.25,//x
							rails1Tab[end-1].position.y-33);//y
					scene.add(rails2Tab[i2]);
				}

				ligneDroite++;
				start = end;
				end += nbrRails[ligneDroite];
				if (rail==="rail1"){
					for (i = start; i < end; i++) {
						rails1Tab[i] = initRails(new THREE.Mesh(geometryRail1[0], materialRail1[0]));
						rails1Tab[i]=emplacementRails(
								rails1Tab[i],//rail
								rails1Tab[start-1].rotation.y-Math.PI/2.0,//rotation.y
								rails1Tab[start-1].position.x-(i-start+1)*30-15,//x
								rails1Tab[start-1].position.y-30-14.81);//y
						scene.add(rails1Tab[i]);
					}
				}
				// 14eme virage (au centre)
				if (rail==="rail2"){
					i2++;
					rails2Tab[i2] = initRails(new THREE.Mesh(geometryRail2[0], materialRail2[0]));
					rails2Tab[i2]=emplacementRails(
							rails2Tab[i2],//rail
							Math.PI/2.0,//rotation.y
							rails1Tab[end-1].position.x-33.5,//x
							rails1Tab[end-1].position.y-11.25);//y
					scene.add(rails2Tab[i2]);
				}

				// ajout des axes
				if (rail==="rail1" && afficherAxes){
					rails1Tab.forEach((rail1Tab) => {
						rail1Tab.add(new THREE.AxesHelper(500));
					});
				}
				// ajout des axes
				if (rail==="rail2" && afficherAxes){
					rails2Tab.forEach((rail2Tab) => {
						rail2Tab.add(new THREE.AxesHelper(500));
					});
				}

			}

			function animateLocomotive() {
				if (locomotive){
					//si le train a été upload
					if(rails1Tab[numRail]) {
						//si les rails ont été upload
						if(locomotive.position.x === target.x[1] &&
								locomotive.position.y === target.y[1]){
							//si on a atteint le target

							// go to next rail:
							numRail++;
							if (numRail>=nbrTotalRails){
								//si on a fait un tour dans le sens horaire
								//retour au rail zero
								numRail=0;
								//on incremente de -2PI car on tourne en rond:
								rotationTour+=-2*Math.PI;
								if(debug){
									console.log("un tour de plus");
								}

							}
							if(numRail!==numRailDouble || (numRail===numRailDouble && doubleRailOk)){
								//si on n'est pas au niveau du double virage

								//calcul de toutes les possibilités des points secondaires pour l'interpolation de bezier
								let targetDemi = {};
								if(locomotive.rotation.y-(rotationTour+rails1Tab[numRail].rotation.y)===Math.PI/2){
									//si c'est un virage de +PI/2 par rapport à la loco
									if (locomotive.position.x-rails1Tab[numRail].position.x>0){
										if (locomotive.position.y-rails1Tab[numRail].position.y>0){
											targetDemi={ x : target.x[1], y : rails1Tab[numRail].position.y };//1
											if(debug){
												console.log("virage de type 1");
											}
										}else if (locomotive.position.y-rails1Tab[numRail].position.y<0){
											targetDemi={ x : rails1Tab[numRail].position.x, y : target.y[1] };//7
											if(debug){
												console.log("virage de type 7");
											}
										}
									} else if (locomotive.position.x-rails1Tab[numRail].position.x<0){
										if (locomotive.position.y-rails1Tab[numRail].position.y>0){
											targetDemi={ x : rails1Tab[numRail].position.x, y : target.y[1] };//8
											if(debug){
												console.log("virage de type 8");
											}
										}else if (locomotive.position.y-rails1Tab[numRail].position.y<0){
											targetDemi={ x : target.x[1], y : rails1Tab[numRail].position.y };//2
											if(debug){
												console.log("virage de type 2");
											}
										}
									}
									if(debugSecondaire){
										console.log("loco : " + locomotive.position.x + "; " + locomotive.position.y+ "; " + (locomotive.rotation.y*(180/Math.PI))+"°\n"
												+"next position temp : \n"
												+ targetDemi.x + "; " + targetDemi.y + "\n"
												+"next position : \n"
												+"rail_"+numRail+" : " + rails1Tab[numRail].position.x + "; " + rails1Tab[numRail].position.y + "; " + ((rotationTour+rails1Tab[numRail].rotation.y)*(180/Math.PI)) + "°");
									}

								} else if(locomotive.rotation.y-(rotationTour+rails1Tab[numRail].rotation.y)===-Math.PI/2){
									//si c'est un virage de -PI/2 par rapport à la loco
									if (locomotive.position.x-rails1Tab[numRail].position.x>0){
										if (locomotive.position.y-rails1Tab[numRail].position.y>0){
											targetDemi={ x : rails1Tab[numRail].position.x, y : target.y[1] };//6
											if(debug){
												console.log("virage de type 6");
											}
										}else if (locomotive.position.y-rails1Tab[numRail].position.y<0){
											targetDemi={ x : target.x[1], y : rails1Tab[numRail].position.y };//4
											if(debug){
												console.log("virage de type 4");
											}
										}
									} else if (locomotive.position.x-rails1Tab[numRail].position.x<0){
										if (locomotive.position.y-rails1Tab[numRail].position.y>0){
											targetDemi={ x : target.x[1], y : rails1Tab[numRail].position.y };//3
											if(debug){
												console.log("virage de type 3");
											}
										}else if (locomotive.position.y-rails1Tab[numRail].position.y<0){
											targetDemi={ x : rails1Tab[numRail].position.x, y : target.y[1] };//5
											if(debug){
												console.log("virage de type 5");
											}
										}
									}
									if(debugSecondaire){
										console.log("loco : " + locomotive.position.x + "; " + locomotive.position.y+ "; " + (locomotive.rotation.y*(180/Math.PI))+"°\n"
												+"next position temp : \n"
												+ targetDemi.x + "; " + targetDemi.y + "\n"
												+"next position : \n"
												+"rail_"+numRail+" : " + rails1Tab[numRail].position.x + "; " + rails1Tab[numRail].position.y + "; " + ((rotationTour+rails1Tab[numRail].rotation.y)*(180/Math.PI)) + "°");
									}

								} else if(locomotive.rotation.y-(rotationTour+rails1Tab[numRail].rotation.y)===0){
									//s'il n'y a pas de rotation entre la loco et le prochain rail
									targetDemi={ x : (rails1Tab[numRail].position.x+target.x[1])/2, y : (rails1Tab[numRail].position.y+target.y[1])/2 };
									if(debug){
										console.log("ligne droite");
									}
								} else {
									//si ce n'est pas un angle droit ou une ligne droite alors probleme
									console.log("/!\\ ERROR : trajectoire non reconnue !!!");
									if(debugSecondaire){
										console.log("loco : " + locomotive.position.x + "; " + locomotive.position.y+ "; " + (locomotive.rotation.y*(180/Math.PI))+"°\n"
												+"target précédent : \n"
												+ targetDemi.x + "; " + targetDemi.y + "\n"
												+"next position : \n"
												+"rail_"+numRail+" : " + rails1Tab[numRail].position.x + "; " + rails1Tab[numRail].position.y + "; " + ((rotationTour+rails1Tab[numRail].rotation.y)*(180/Math.PI)) + "°");
									}
								}

								//on defini le prochian target avec la valeur du milieu et la destination finale
								target = { x : [targetDemi.x/*demi*/,rails1Tab[numRail].position.x], y: [targetDemi.y/*demi*/,rails1Tab[numRail].position.y] , rotation : [(rotationTour+rails1Tab[numRail].rotation.y)/*total*/]};
								//on a passé le double virage
								doubleRailOk=false;
							} else if(!doubleRailOk && numRail===numRailDouble){
								//si on est au niveau du double virage
								//on calcul le target du mileu
								target = { x : [rails1Tab[numRail-1].position.x, (rails1Tab[numRail].position.x+rails1Tab[numRail-1].position.x)/2], y: [(rails1Tab[numRail].position.y+rails1Tab[numRail-1].position.y)/2, (rails1Tab[numRail].position.y+rails1Tab[numRail-1].position.y)/2] , rotation : [rotationTour+rails1Tab[numRail].rotation.y-Math.PI/2/*total*/]};
								doubleRailOk=true;
								// pour revenir au bon rail
								numRail--;
								if(debug) {
									console.log("double virage");
								}
								if(debugSecondaire){
									console.log("loco : " + locomotive.position.x + "; " + locomotive.position.y + "; " + (locomotive.rotation.y * (180 / Math.PI)) + "°\n"
											+ "next position temp : \n"
											+ target.x[0] + "; " + target.y[0] + "\n"
											+ "next position : \n"
											+ "rail_temp : " + target.x[1] + "; " + target.y[1] + "; " + (target.rotation[0] * (180 / Math.PI)) + "°");
								}
							}
							tween.to(target, vitesseTween);
							tween.start();

						} else {
							//si on a pas atteint le target:
							if(rotationTour>-2*Math.PI){
								//si on est au premier tour
								if(debugSecondaire){
									//on dessine la trajectoire
									var point = new THREE.AxesHelper(20);
									point.position.set( locomotive.position.x, locomotive.position.y, locomotive.position.z+50);
									point.rotation.z=locomotive.rotation.y;
									scene.add(point);
								}
							}
							//update le tween
							TWEEN.update();
						}
					}
					//allumer ou eteindre les lumieres en fonction de la position du soleil
					if(allumerLumieres){
						spotLightLocoD.intensity=5;
						spotLightLocoG.intensity=5;
					}else{
						spotLightLocoD.intensity=0;
						spotLightLocoG.intensity=0;
					}
				}
			}

			function tweenInit(){
				var position = { x : 0, y: 0, rotation: 0 };
				target = { x : [rails1Tab[numRail].position.x/*demi*/,rails1Tab[numRail].position.x/*fin*/], y: [position.y/*demi*/,rails1Tab[numRail].position.y/*fin*/] , rotation : [(rotationTour+rails1Tab[numRail].rotation.y)]};


				tween = new TWEEN.Tween(position)
						.to(target, vitesseTween)
						.onUpdate(function(object){
							locomotive.position.x = object.x;
							locomotive.position.y = object.y;
							locomotive.rotation.y = object.rotation;
							if(debugSecondaire) {
								console.log("en mouvement : x : " + object.x + "; y : " + object.y + "; alpha : " + object.rotation);
							}
						})
						.easing(TWEEN.Easing.Linear.None)
						.interpolation(TWEEN.Interpolation.Bezier)
						.start();
				if(debug) {
					console.log("Tween Locomotive ok");
				}
			}

			function animateSun(time){
				//changement position soleil
				if(light){
					light.position.x=Math.cos(time/10000)*1000;
					light.position.z=Math.sin(time/10000)*1000;
				}
				//changer l'état des lumieres de la loco si le soleil et en dessous de l'horizon
				allumerLumieres = light.position.z <= 100;
			}

			function animate(time) {
				animateLocomotive();
				animateSun(time);


				controls.update();
				render();
				requestAnimationFrame( animate );
			}

			function render() {
				renderer.render(scene, camera);
			}

			// gestion redimensionnement fenetre
			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);
			}

		</script>
	</body>
</html>